#################################################################
# INFERNAL
# top level Makefile: installation, documentation
# CVS $Id$
#################################################################
# @LICENSE@
#################################################################

# On most Unices, you can build the package without modifying anything 
#   by just typing "./configure; make".
#
# You may want to modify the following make variables:
#   BINDIR  - where the executables will be installed by a 'make install'
#   MANDIR  - where the man pages will be installed by a 'make install'
#   CC      - which compiler to use
#   CFLAGS  - compiler flags to use

# where you want things installed
# Sort of uses GNU coding standards. ${prefix} might be /usr/local.
# ${exec_prefix} gives you some flexibility for installing architecture
# dependent files (e.g. the programs): an example ${exec_prefix} might be
# /nfs/share/irix64/
#
prefix      = @prefix@
exec_prefix = @exec_prefix@
BINDIR      = @bindir@
MANDIR      = @mandir@

# how to install the man pages; 
# cp is generally fine, unless you preformat your pages.
#
INSTMAN   = cp
MANSUFFIX = 1

# your compiler and compiler flags
#
CC     = @CC@
CFLAGS = @CFLAGS@

#######
## You should not need to modify below this line.
## Some of it is concerned with maintenance of the development version
## and building the release (indeed, several commands will only work in 
## St. Louis)
#######
SHELL       = /bin/sh
BASENAME    = "infernal"
PACKAGE     = "Infernal"
RELEASE     = "0.54"
RELCODE     = "rel0_54"
RELEASEDATE = "Jan 2003"
COPYRIGHT   = "Copyright \(C\) 2002-2003 Washington University, Saint Louis"
LICENSE     = "Freely distributed under the GNU General Public License \(GPL\)"
LICENSETAG  = gnu
COMPRESS    = gzip
FTPDIR      = /nfs/ftp/eddy/software/infernal

# The program lists below for INFERNAL are not necessarily
# a complete manifest. They are the list of stable programs that the
# package will install. There must eventually be a man page for each one of them
# in man/. (The list in src/Makefile.in is the complete manifest
# of INFERNAL programs.)
#
PROGS = cmalign\
	cmbuild\
	cmscore\
	cmsearch

# all: if we don't have precompiled binaries, compiles all packages, 
#      and moves the supported executables into binaries/ subdirectory.
#
all: version.h
	(cd squid; make CC="$(CC)" CFLAGS="$(CFLAGS)"; make module);\
	(cd src;   make CC="$(CC)" CFLAGS="$(CFLAGS)"; make module);\

# version.h: 
#   create the version.h file that will define stamps used by 
#   squidcore.c's Banner(), which is called by all executables to
#   print a standard package/copyright/license banner;
#   then puts copies of version.h in all directories that are 
#   going to need it -- INFERNAL src/ and any modules of mine that
#   also produce installed executables (squid/)
#
version.h:
	@echo "Creating version.h..."
	@echo "/* version.h -- automatically generated by a Makefile. DO NOT EDIT. */" > version.h
	@echo "#define PACKAGE     \"$(PACKAGE)\""     >> version.h
	@echo "#define RELEASE     \"$(RELEASE)\""     >> version.h
	@echo "#define RELEASEDATE \"$(RELEASEDATE)\"" >> version.h
	@echo "#define COPYRIGHT   \"$(COPYRIGHT)\""   >> version.h
	@echo "#define LICENSE     \"$(LICENSE)\""     >> version.h
	@cp version.h squid/
	@cp version.h src/

# dist: build a new distribution directory in infernal-$RELEASE
#       Exports from the CVS repository.
#       tags RCS files with $(RELCODE) for later reconstruction
#       squid RCS files are tagged with infernal_(RELCODE).
#       Adds a license statement to each file that has a @ LICENSE @ line.
#       Virtually identical to squid's make dist -- keep them in sync!
dist:
	# Delete old versions of the same release
	#
	@if test -d ${BASENAME}-$(RELEASE);        then rm -rf ${BASENAME}-$(RELEASE);        fi
	@if test -e ${BASENAME}-$(RELEASE).tar;    then rm -f  ${BASENAME}-$(RELEASE).tar;    fi
	@if test -e ${BASENAME}-$(RELEASE).tar.Z;  then rm -f  ${BASENAME}-$(RELEASE).tar.Z;  fi
	@if test -e ${BASENAME}-$(RELEASE).tar.gz; then rm -f  ${BASENAME}-$(RELEASE).tar.gz; fi
	# 
	# CVS tag and extract. -c: make sure we committed;
	#                      -F: allow more than one "make dist" per rel
	# prep: must have done "cvs commit", and CVSROOT must be set
	# We also need the squid library, so tag and export it too.
	#
	cvs tag -F $(RELCODE)
	cvs export -r $(RELCODE) -d ${BASENAME}-${RELEASE} ${BASENAME}
	cvs rtag -F ${BASENAME}_${RELCODE} squid
	(cd ${BASENAME}-${RELEASE}/; cvs export -r ${BASENAME}_${RELCODE} -d squid squid)
	# 
	# Put a copy of sqc in testsuite; that's the only script
	# we need from ssdk.
	#
	cp ssdk/sqc ${BASENAME}-${RELEASE}/testsuite/
	# 
	# Make the configure scripts from configure.in's
	#
	(cd ${BASENAME}-${RELEASE};       autoconf)
	(cd ${BASENAME}-${RELEASE}/squid; autoconf)
	#
	# Attach license stamps on files that need 'em (replace LICENSE keyword)
	# licenseadd.pl is basically harmless, so we can overannotate here by
	# trying to licenseadd everything.
	#
	find ${BASENAME}-${RELEASE} -type f -exec ssdk/licenseadd.pl Licenses/$(LICENSETAG) {} \;
	#
	# Remove CVS-controlled files/directories that don't belong in the distro
	#
	-rm -rf ${BASENAME}-${RELEASE}/Licenses
	-rm -rf ${BASENAME}-${RELEASE}/00CHECKLIST
	-rm -rf ${BASENAME}-${RELEASE}/configure.in
	-rm -rf ${BASENAME}-${RELEASE}/squid/configure.in
	-rm -rf ${BASENAME}-${RELEASE}/Bugs
	-rm -rf ${BASENAME}-${RELEASE}/Manuscripts
	#
	# Set file permissions.
	#
	find ${BASENAME}-${RELEASE} -type f -exec chmod +r {} \;
	chmod +x ${BASENAME}-${RELEASE}/testsuite/sqc
	#
	# Packaging commands
	#
	tar cvf ${BASENAME}-${RELEASE}.tar ${BASENAME}-${RELEASE}
	$(COMPRESS) ${BASENAME}-$(RELEASE).tar

# "make ftpdist" installs a new tarball on the FTP site.
# (StL specific)
ftpdist:
	cp -f ${BASENAME}-$(RELEASE).tar.gz ${FTPDIR}/
	rm -f ${FTPDIR}/${BASENAME}.tar.gz 
	ln -s ${FTPDIR}/${BASENAME}-${RELEASE}.tar.gz ${FTPDIR}/${BASENAME}.tar.gz 

# "make check" runs a set of sqc exercises in the test suite, at level 4.
# To run faster, reduce the level (level 1 runs a few tests, level 4
# runs a lot). Also runs the bug tests, if we're in StL and we have 
# the dev code's Bugs tracking subdirectory.
#
check:
	(cd testsuite; ./sqc -p ../squid 4 exercises.sqc ../src)
	if test -e Bugs; then\
	   (cd Bugs; ../testsuite/sqc -p ../squid 2 bugs.sqc ../src);\
        fi

# "make install" installs the programs in BINDIR
#
install:
	for file in $(PROGS); do\
	   cp src/$$file $(BINDIR)/;\
	done

# "make clean" removes almost everything except configuration files
#              and binaries.
clean:
	-rm -f *.o *~ Makefile.bak core TAGS gmon.out
	(cd src;       make clean)
	(cd squid;     make clean)

# "make distclean" leaves a pristine source distribution.
#
distclean:
	-rm config.cache config.log config.status
	-rm version.h
	make clean
	(cd src;       make distclean)
	(cd squid;     make distclean)
	-rm Makefile

